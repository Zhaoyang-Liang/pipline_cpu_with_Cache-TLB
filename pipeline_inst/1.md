
#### syscall


```text
memory_initialization_radix=16;
memory_initialization_vector=AC010000 40016800 00010882 3421001F 24020008 10220002 40017000 24210004 40817000 8C010000 42000018 40017000 24210004 40817000 8C010000 42000018 24010001 40816000 0000000C 24010001 24020002 00411821 AC030000 08000013;
```


| 序号 | 地址 (Hex) | 机器码      | 汇编 / 说明                       |
| -- | -------- | -------- | ---------------------------------------- |
| 1  | 0x00     | AC010000 | `sw $1, 0($0)`  保存 `$1` 到 `Mem[0]`       |
| 2  | 0x04     | 40016800 | `mfc0 $1, $13`  读取 CAUSE 寄存器到 `$1`       |
| 3  | 0x08     | 00010882 | `srl $1, $1, 2`  右移 2 位，将异常码移到低位         |
| 4  | 0x0C     | 3421001F | `andi $1, $1, 0x1F`  取低 5 位异常码           |
| 5  | 0x10     | 24020008 | `addiu $2, $0, 8`  `$2 = 8`（SYSCALL 异常码） |
| 6  | 0x14     | 10220002 | `beq $1, $2, 2`  若为 SYSCALL，分支到地址 `0x20` |
| 7  | 0x18     | 40017000 | `mfc0 $1, $14`  从 EPC 读出异常发生地址           |
| 8  | 0x1C     | 24210004 | `addiu $1, $1, 4`  EPC += 4              |
| 9  | 0x20     | 40817000 | `mtc0 $1, $14`  将更新后的 EPC 写回             |
| 10 | 0x24     | 8C010000 | `lw $1, 0($0)`  恢复 `$1`                  |
| 11 | 0x28     | 42000018 | `eret`  从异常返回                            |
| 12 | 0x2C     | 40017000 | `mfc0 $1, $14`  SYSCALL 分支：读 EPC         |
| 13 | 0x30     | 24210004 | `addiu $1, $1, 4`  SYSCALL：EPC += 4      |
| 14 | 0x34     | 40817000 | `mtc0 $1, $14`  SYSCALL：写回 EPC           |
| 15 | 0x38     | 8C010000 | `lw $1, 0($0)`  SYSCALL：恢复 `$1`          |
| 16 | 0x3C     | 42000018 | `eret`  SYSCALL：从异常返回                    |
| 17 | 0x40     | 24010001 | `addiu $1, $0, 1`  `$1 = 1`，初始化          |
| 18 | 0x44     | 40816000 | `mtc0 $1, $12`  写 STATUS 寄存器             |
| 19 | 0x48     | 0000000C | `syscall`  触发 SYSCALL 异常                 |
| 20 | 0x4C     | 24010001 | `addiu $1, $0, 1`  异常返回后 `$1 = 1`        |
| 21 | 0x50     | 24020002 | `addiu $2, $0, 2`  `$2 = 2`              |
| 22 | 0x54     | 00411821 | `addu $3, $2, $1`  `$3 = $2 + $1 = 3`    |
| 23 | 0x58     | AC030000 | `sw $3, 0($0)`  把结果 `$3` 存到 `Mem[0]`     |
| 24 | 0x5C     | 08000013 | `j 0x4C`  跳回 `0x4C` 形成死循环                |


#### AdEL

程序入口地址0x40H
```bash
0x50: 8C010001  ; lw $1, 1($0)
```

```text
加载地址 = $0 + 1 = 0x00000001

lw 需要 4 字节对齐的地址（最低 2 位必须为 0）

地址 1 不对齐 ? 触发 AdEL（Address Error Load）异常

在 MIPS 架构中，AdEL 异常码 = 4
```


```text
memory_initialization_radix=16;
memory_initialization_vector= AC010000 40016800 00010882 3421001F 24020004 10220003 40017000 24210004 40817000 8C010000 42000018 40017000 24210004 40817000 8C010000 42000018 24010001 40816000 240200AA AC020000 8C010001 24010001 24020002 00411821 AC030004 08000019;
```

| 地址   | 机器码      | 汇编                  | 说明                       |
| ---- | -------- | ------------------- | ------------------------ |
| 0x00 | AC010000 | `sw $1, 0($0)`      | 保存 `$1`                  |
| 0x04 | 40016800 | `mfc0 $1, $13`      | 读取 CAUSE                 |
| 0x08 | 00010882 | `srl $1, $1, 2`     | 提取 ExcCode               |
| 0x0C | 3421001F | `andi $1, $1, 0x1F` | 取异常码                     |
| 0x10 | 24020004 | `addiu $2, $0, 4`   | `$2=4`（AdEL 异常码）         |
| 0x14 | 10220003 | `beq $1,$2,3`       | 若 ExcCode=4，跳到 AdEL 处理分支 |
| 0x18 | 40017000 | `mfc0 $1,$14`       | 默认异常：读 EPC               |
| 0x1C | 24210004 | `addiu $1,$1,4`     | EPC += 4                 |
| 0x20 | 40817000 | `mtc0 $1,$14`       | 写回 EPC                   |
| 0x24 | 8C010000 | `lw $1,0($0)`       | 恢复 `$1`                  |
| 0x28 | 42000018 | `eret`              | 返回（默认异常）                 |
| 0x2C | 40017000 | `mfc0 $1,$14`       | AdEL 异常分支：读 EPC          |
| 0x30 | 24210004 | `addiu $1,$1,4`     | EPC += 4                 |
| 0x34 | 40817000 | `mtc0 $1,$14`       | 写回 EPC                   |
| 0x38 | 8C010000 | `lw $1,0($0)`       | 恢复 `$1`                  |
| 0x3C | 42000018 | `eret`              | 返回（AdEL 异常）              |
| 0x40 | 24010001 | `addiu $1,$0,1`     | 程序初始化 `$1=1`             |
| 0x44 | 40816000 | `mtc0 $1,$12`       | 写 STATUS 寄存器             |
| 0x48 | 240200AA | `addiu $2,$0,0xAA`  | `$2=0xAA`                |
| 0x4C | AC020000 | `sw $2,0($0)`       | 把 `$2` 存入 Mem[0]         |
| 0x50 | 8C010001 | `lw $1,1($0)`       | ?? 非对齐访问 → 触发 AdEL 异常    |
| 0x54 | 24010001 | `addiu $1,$0,1`     | 异常返回后继续执行                |
| 0x58 | 24020002 | `addiu $2,$0,2`     | `$2=2`                   |
| 0x5C | 00411821 | `addu $3,$2,$1`     | `$3=3`                   |
| 0x60 | AC030004 | `sw $3,4($0)`       | 存结果到 Mem[4]              |
| 0x64 | 08000019 | `j 0x64`            | 死循环                      |


#### 计时器

0x70入口

```
AC010000 AC020004 40016800 00010882 3421001F 24020000 10220006 40017000 24210004 40817000 8C020004 8C010000 42000018 40016800 0001089E 34210001 24020001 10220003 8C020004 8C010000 42000018 4001B800 4081B800 2401009C 40817000 8C020004 8C010000 42000018 24018001 40816000 24010000 40819000 24010005 4081B800 24010001 24020002 24030000 24630001 08000025 00411821 AC030008 08000029
```

| 步骤 | 地址            | 说明                                      |
| -- | ------------- | --------------------------------------- |
| ①  | **0x70C0x84** | 初始化：STATUS、COUNT、COMPARE（定时器设为5触发）      |
| ②  | **0x88C0x98** | 进入等待循环（自增 `$3`，等待中断触发）                  |
| ③  | **中断触发**      | COUNT==COMPARE → TI=1 → 触发中断（ExcCode=0） |
| ④  | **0x34C0x6C** | 异常处理程序运行：判断中断类型，清除TI，设置 EPC=0x9C        |
| ⑤  | **eret 返回**   | 从 0x9C 开始继续执行                           |
| ⑥  | **0x9CC0xA4** | 计算 `$3=$2+$1=3`，写内存，进入死循环               |


#### break

```text
memory_initialization_radix=16;
memory_initialization_vector= AC010000 AC020004 40016800 00010882 3421001F 24020000 10220006 40017000 24210004 40817000 8C020004 8C010000 42000018 40016800 0001089E 34210001 24020001 10220003 8C020004 8C010000 42000018 4001B800 4081B800 2401009C 40817000 8C020004 8C010000 42000018 24018001 40816000 24010000 40819000 24010005 4081B800 24010001 24020002 24030000 24630001 08000025 00411821 AC030008 08000029;
```

| 地址   | 机器码      | 汇编指令                | 说明                                 |
| ---- | -------- | ------------------- | ---------------------------------- |
| 0x00 | AC010000 | `sw $1, 0($0)`      | 备份 `$1` 到内存                        |
| 0x04 | 40016800 | `mfc0 $1, $13`      | 读 CAUSE                            |
| 0x08 | 00010882 | `srl $1, $1, 2`     | CAUSE 右移 2，取 ExcCode 到低位           |
| 0x0C | 3421001F | `andi $1, $1, 0x1F` | 取异常码低 5 位                          |
| 0x10 | 24020009 | `addiu $2, $0, 9`   | `$2=9`（BREAK 异常码）                  |
| 0x14 | 10220005 | `beq $1, $2, 5`     | 若是 BREAK → 跳到 `0x2C`（`0x18 + 5*4`） |
| 0x18 | 40017000 | `mfc0 $1, $14`      | 默认异常：读 EPC                         |
| 0x1C | 24210004 | `addiu $1, $1, 4`   | EPC += 4                           |
| 0x20 | 40817000 | `mtc0 $1, $14`      | 写回 EPC                             |
| 0x24 | 8C010000 | `lw $1, 0($0)`      | 恢复 `$1`                            |
| 0x28 | 42000018 | `eret`              | 默认异常返回                             |
| 0x2C | 40017000 | `mfc0 $1, $14`      | **BREAK 分支**：读 EPC                 |
| 0x30 | 24210004 | `addiu $1, $1, 4`   | EPC += 4（越过 `break` 指令）            |
| 0x34 | 40817000 | `mtc0 $1, $14`      | 写回 EPC                             |
| 0x38 | 8C010000 | `lw $1, 0($0)`      | 恢复 `$1`                            |
| 0x3C | 42000018 | `eret`              | BREAK 返回                           |
| 0x40 | 24010001 | `addiu $1, $0, 1`   | 测试：$1=1                            |
| 0x44 | 40816000 | `mtc0 $1, $12`      | 写 STATUS                           |
| 0x48 | 24010001 | `addiu $1, $0, 1`   | 正常流程                               |
| 0x4C | 24020002 | `addiu $2, $0, 2`   | 正常流程                               |
| 0x50 | 0000000D | `break`             | 触发 BREAK 异常（ExcCode=9）             |
| 0x54 | 00411821 | `addu $3, $2, $1`   | 异常返回后继续：$3=$2+$1=3                 |
| 0x58 | AC030000 | `sw $3, 0($0)`      | 结果写 `Mem[0]`                       |
| 0x5C | 08000017 | `j 0x5C`            | 死循环（自跳转）                           |
