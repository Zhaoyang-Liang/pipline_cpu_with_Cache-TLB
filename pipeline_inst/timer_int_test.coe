memory_initialization_radix=16;
memory_initialization_vector=
; ============================================
; 异常处理程序 (Exception Handler) - 地址 00H-3FH
; ============================================
; 00H: 保存上下文：保存$1到内存
AC010000  ; sw $1, 0($0)  - 保存$1到Mem[0]

; 04H: 保存$2到内存
AC020004  ; sw $2, 4($0)  - 保存$2到Mem[4]

; 08H: 读取CAUSE寄存器，获取异常码
40016800  ; mfc0 $1, $13  - 读取CAUSE寄存器到$1

; 0CH: 提取异常码 (CAUSE[6:2]) - 右移2位
00010882  ; srl $1, $1, 2  - 右移2位，将ExcCode移到低5位

; 10H: 提取异常码（继续）- 取低5位
3421001F  ; andi $1, $1, 0x1F  - 取低5位（异常码）

; 14H: 判断是否为中断（异常码0）
24020000  ; addiu $2, $0, 0  - $2 = 0（中断异常码）

; 18H: 判断异常类型（继续）- 如果是中断，跳转到20H
10220002  ; beq $1, $2, 2  - 如果是中断，跳转到20H (1CH + 4 + 4*2 = 20H)

; 1CH: 默认处理（非中断异常，统一返回）
40017000  ; mfc0 $1, $14  - 读取EPC
24210004  ; addiu $1, $1, 4  - EPC += 4
40817000  ; mtc0 $1, $14  - 写回EPC
8C020004  ; lw $2, 4($0)  - 恢复$2
8C010000  ; lw $1, 0($0)  - 恢复$1
42000018  ; eret  - 返回

; 20H: 中断处理程序 - 读取CAUSE，检查是否为定时器中断
40016800  ; mfc0 $1, $13  - 读取CAUSE寄存器到$1

; 24H: 检查TI位（CAUSE[30]）
0001089E  ; srl $1, $1, 30  - 右移30位，将TI位移到bit 0

; 28H: 提取TI位
34210001  ; andi $1, $1, 1  - 取bit 0（TI位）

; 2CH: 判断是否为定时器中断（TI=1）
24020001  ; addiu $2, $0, 1  - $2 = 1

; 30H: 判断是否为定时器中断（继续）- 如果是，跳转到38H
10220002  ; beq $1, $2, 2  - 如果是定时器中断，跳转到38H (34H + 4 + 4*2 = 38H)

; 34H: 其他中断处理（非定时器中断，统一返回）
40017000  ; mfc0 $1, $14  - 读取EPC
8C020004  ; lw $2, 4($0)  - 恢复$2
8C010000  ; lw $1, 0($0)  - 恢复$1
42000018  ; eret  - 返回

; 38H: 定时器中断处理 - 清除TI位（通过写入COMPARE寄存器）
4001B800  ; mfc0 $1, $11  - 读取COMPARE寄存器到$1

; 3CH: 写回COMPARE寄存器（清除TI位）
4081B800  ; mtc0 $1, $11  - 写回COMPARE寄存器（清除TI位）

; 44H: 定时器中断处理（继续）- 恢复$2
8C020004  ; lw $2, 4($0)  - 恢复$2

; 48H: 定时器中断处理（继续）- 恢复$1
8C010000  ; lw $1, 0($0)  - 恢复$1

; 4CH: 定时器中断处理（继续）- 返回（EPC已由CP0自动设置，无需修改）
42000018  ; eret  - 返回

; ============================================
; 测试程序 (Test Program) - 地址 60H (CPU复位地址)
; ============================================
; 60H: 初始化：设置STATUS寄存器（使能中断，使能定时器中断）
24018001  ; addiu $1, $0, 0x8001  - $1 = 0x8001 (IE=1, IM[15]=1，定时器中断对应IP[7])

; 64H: 初始化（继续）
40816000  ; mtc0 $1, $12  - 写入STATUS寄存器

; 68H: 初始化COUNT寄存器（从0开始计数）
24010000  ; addiu $1, $0, 0  - $1 = 0

; 6CH: 初始化COUNT（继续）
40819000  ; mtc0 $1, $9  - 写入COUNT寄存器

; 70H: 初始化COMPARE寄存器（设置比较值为5，触发中断）
24010005  ; addiu $1, $0, 5  - $1 = 5

; 74H: 初始化COMPARE（继续）
4081B800  ; mtc0 $1, $11  - 写入COMPARE寄存器

; 78H: 正常程序：初始化寄存器
24010001  ; addiu $1, $0, 1  - $1 = 1

; 7CH: 正常程序（继续）
24020002  ; addiu $2, $0, 2  - $2 = 2

; 80H: 等待定时器中断（循环等待）
24030000  ; addiu $3, $0, 0  - $3 = 0（循环计数器）

; 84H: 等待循环（继续）- 增加计数器
24430001  ; addiu $3, $3, 1  - $3 = $3 + 1

; 88H: 等待循环（继续）- 跳转回84H（等待中断）
08000021  ; j 0x84  - 跳转到84H（死循环等待中断）

; 8CH: 中断返回后继续执行（定时器中断处理后应该返回到这里）
00411821  ; addu $3, $2, $1  - $3 = $2 + $1 = 3

; 90H: 存储结果
AC030008  ; sw $3, 8($0)  - 存储结果到Mem[8]

; 94H: 程序结束（死循环）
08000025  ; j 0x94  - 跳转到94H（死循环）

