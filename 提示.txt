4.5川处理寄存器写后读数据相关引发的流水线冲突
产生由寄存器写后读数据相关所引发的流水线冲突的场景是:产生结果的指令（‘《写
者”）尚未将结果写回到通用寄存器堆中’而需要这个结果的指令（“读者”）巳经在译码阶
段了’此刻它从通用寄存器堆中读出的数值是｜日值而非新值。
如何避免产生这种错误呢?一种直观的解决思路是:让需安结果的指令在详码流水级＿
直等待’直到产生结果的指令将结果写人到通用寄存器堆’才可以进人到下―级的执行流水
级中。这＿节我们就采用这种思路来调整设计°
这套设计思路中的关键点在于控制译码流水级指令前进还是阻塞的条件如何生成’其核
心是判断处于流水线不同阶段的指令是否存在会引发冲突的‘写后读”相关关系°结合我们
设计的五级流水线CPU的结构,这个判断可以具体描述为:处于译码流水级的指令具有来
自非0号寄存器的源操作数’那么如果这些源操作数an中任何-个的寄存器号与当前时刻处于
执行级、访存级或写回级的指令的目的操作数的寄存器号（非0号）相同,则表明处于译码
级的指令与执行级、访存级或写回级的指令存在会引发冲突的“写后读”相关关系°
在上面给出的具体描述中’有些读者可能不理解为什么译码级指令的源寄存器号也要和
写回级的指令的目的寄存器号进行比较°出现这个问题的原因是’没有理解对寄存器堆同时
读写同＿项时读出数据的行为°请回想―下第3章实践任务一中所分析的寄存器堆的行为’
在写使能有效的这个时钟周期（写使能将被这个时钟周期与下＿个时钟周期之间的上升沿采
样）’读端口的地址若和写地址＿样,那么读出数据的端口上只能出现这―项的旧值而非此时
写端口的写人数据°只要理解这个时序特性’自然就会知道译码级的指令与写回级的指令是
要比较寄存器号的°
在把前面给出的描述落实到具体代码实现的过程中’还有＿个隐含的细节容易被初学者
忽视’那就是＿定要保证被比较的两个寄存器号都是有效的°这体现为三个方面°第-,参
与比较的指令到底有没有寄存器的源操作数或是寄存器的目的操作数°比如’ADDlU指令
只有rs＿个寄存器的源操作数, rt域存放的是它的目的操作数的寄存器号°再比如’JAL指
令压根就没有寄存器的源操作数’BNE｀BEQ、JR这三条转移指令则没有寄存器的目的操作
数°如果在写比较逻辑的时候没有考虑到这些特例,那么写出来的处理器虽然不会出错,但
是会在某些情况下出现不必要的阻塞,导致损失性能。第二,如果指令的定义确实有寄存器
的源操作数或目的操作数,但是寄存器号为0’那么也不用进行比较°因为在MIPS架构下’
0号寄存器的值恒为0,所以对这个寄存器存在的相关关系不需要做特殊处理。第三,用来
第4章简单流水线CPU设计 ／27
进行比较的流水级上到底有没有指令,如果没有指令’那么这＿级流水缓存中的寄存器号、
指令类型等信息都是无效的。
完成了会引发冲突的“写后读’,相关关系的判断后’最后-个步骤就是如何在判断条件
成立的时候,把这条指令阻塞在译码流水级°还记得我们每＿级流水的ready―go信号吗?
在这里,只需要对译码流水级的ready―go信号进行调整就可以了°显然,它不是恒为l了’
如果发现译码流水级的指令与后面执行、访存、写回三个流水级的指令间存在会引发冲突的
“写后读｀相关关系’那么就要把ready-go信号置为0°
45.2转移计算未完成
在“写后读,相关中存在―种情况―LoadˉtoˉBranch,即第『条指令是Load,第j＋l条
指令是转移（跳转或分支）指令’转移指令至少有―个源寄存器与Load指令的目的寄存器
相同’也就是Branch与Load存在“写后读相关”°在这种情况下’当转移指令在译码级时’
Load指令在执行级无法获得Load结果,因而转移指令无法计算正确的跳转方向或跳转目标
称为‘』转移计算未完成”°此时由译码级送到取指级的转移信息（brbus）参与生成的nextPC
就是不正确的,而nextPC是由preˉIF维护的’也就是说preˉIF未准备好nextPC°所以我们应
该在译码级送到取指级的brbus上新增―个控制信号brstall,用来表示转移计算未完成。另
外’要为preˉIF新增一个ready-go,当brstall为l时’组合逻辑置read-go为0’进而置to
fSvalid为0; IF级看到tofbvalld为0’当IF级的allowin为l时,时序逻辑会置IFˉvalid为
0。不过,即使漏掉了这＿处理,没有在pre＿IF中新增ready-go信号’也不会出错’原因在
于:既然转移计算未完成’那么转移指令就会阻塞在译码级’进而导致转移延迟槽指令阻塞在
取指级’此时就算preˉIF级置tofSvaljd为l’也会因为IFˉallowin为0而导致preˉIF级不会
真正流向IF级°等到IFˉallowjn变为］时’转移计算也一定完成了（brbus上brstall为0）°
另外,在我们的设计里’nextPC是送到指令RAM的地址端口的。当转移计算未完成时
（brbus里的brstall为l）’建议CPU设计者应该控制指令RAM的读使能为0（也就是无
效）°在未引人总线设计时’如果没有注意到这＿点,设计的CPU也不会出错;但是在后续
引人总线设计时’如果没有注意这一点’则很可能会出错°
这一节的内容就到此结束了°是不是短到令人难以置信?既然这―节的内容并不复杂’
那么希望读者通过实践切实掌握它,如果还没有熟


