\documentclass[a4paper]{article}
\input{style/ch_xelatex.tex}
\input{style/scala.tex}
\renewcommand {\thefigure}{\thesection{}.\arabic{figure}}%图片按章标号


% 定义 Verilog 语法
\lstdefinelanguage{Verilog}{
	keywords=[1]{module, endmodule, input, output,  reg, always, begin, end, if, else, case, endcase, assign},
	keywordstyle=[1]\color{blue}\bfseries,
	keywords=[2]{and, or, nand, nor, xor, xnor, buf,wire, not},
	keywordstyle=[2]\color{red},
	sensitive=false, % Verilog 大小写不敏感
	morecomment=[l][commentstyle]{//},
	morecomment=[s]{/*}{*/}, % 块注释
	commentstyle=\color{green}, % 注释风格
	%morestring=[b]", % 字符串
	morecomment=[l][commentstyle]{'},
	morecomment=[l][commentstyle]{"},
	%morestring=[b]' % 字符
}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\lstset{
	language=Verilog,
	basicstyle=\ttfamily\small, % 代码的基本样式
	commentstyle=\color{darkgreen}, % 注释样式
	stringstyle=\color{orange}, % 字符串样式
	numberstyle=\color{gray}, % 设置数字颜色
	numbers=left, % 行号在左侧
	numberstyle=\tiny\color{gray}, % 行号样式
	stepnumber=1, % 行号步进
	breaklines=true, % 自动换行
	frame=single, % 代码框
	tabsize=4, % Tab 大小
	showstringspaces=false, % 不显示字符串中的空格
	extendedchars=true, % 支持扩展字符
}

\usepackage{booktabs}
\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=3cm,bottom=3cm}

\begin{document}

\renewcommand{\figurename}{图}
\renewcommand{\contentsname}{目录}  
\cfoot{\thepage\ of \pageref{LastPage}}
\renewcommand{\abstractname}{\textbf{\Large 摘要}} 

\begin{center}
    \huge{\textbf{TLB Cache AXI总线的五级流水CPU}}
\end{center}

\begin{center}
    \textbf{姓名}：\underline{梁朝阳 2311561} \quad
    \textbf{专业}：\underline{密码科学与技术}
\end{center}

\tableofcontents

\vspace*{1cm}

\noindent{\Large\textbf{摘要}}

\vspace{1em}
本文在已有的AXI总线的五级流水 CPU基础上，完成TLB与I/D Cache的最简实现与集成。TLB采用4项全相联固定映射，支持TLBL/TLBS/Modify等异常；I-Cache与D-Cache均为直映结构、行大小16B，其中I-Cache只读，D-Cache采用写直达+写分配并支持字节访问。通过在MEM阶段生成访存异常并在WB阶段统一仲裁写入CP0，实现了地址异常与TLB异常的正确处理。最后仿真验证模块正确。

最后报告中没有展示完整的代码，所有的代码让我一起上传到github中了：{}\url{https://github.com/Zhaoyang-Liang/pipline_cpu_with_Cache-TLB}
里面包含了所有内容。

\vspace{1em}
\noindent\textbf{关键词：} 五级流水CPU、TLB、I/DCache

\newpage


% \section{实验要求}

% 在现有的五级流水线CPU的基础上，增加TLB模块和cache模块。

% \begin{enumerate}
%     \item 本次实验是学期末综合实验，主要考察大家对TLB和cache的理解和应用，大家根据自己的能力和时间往后做即可，不强制要去全部功能都做出来。
%     \item TLB部分推荐完成TLB模块设计和TLB相关指令和CP0寄存器部分，例外部分大家把握。
%     \item Cache部分至少设计出ICache和DCache，并尝试在CPU中集成测试，其他部分大家把握。
% \end{enumerate}


\section{CPU全局设计图}

\begin{figure}[H]
    \hspace{-6em}
    \includegraphics[width=1.3\linewidth]{img/CPU设计图.jpg}
    \caption{CPU全局设计图}
    \label{fig:CPU全局设计图}
\end{figure}

该图从左到右展示了五级流水主路径及关键访存链路，分点说明如下：
\begin{enumerate}
    \item IF阶段由PC选择逻辑产生取指地址，请求I-Cache，命中则直接返回指令；未命中则通过指令AXI总线向指令存储器（ROM/AXI从设备）发起burst读并回填I-Cache。
    \item ID阶段完成指令译码、寄存器读取和分支判断，产生控制信号并通过旁路单元接收来自EXE/MEM/WB的前递数据以消除数据相关。
    \item EXE阶段执行ALU/乘法运算并形成访存地址。
    \item MEM阶段首先对地址进行对齐检查，再经TLB完成虚拟地址到物理地址的转换，随后访问D-Cache：命中直接返回数据或更新cache行；未命中则通过数据AXI总线访问外部数据存储器（RAM/AXI从设备）并进行行填充。
    \item WB阶段将结果写回寄存器堆，同时处理HI/LO与CP0寄存器更新并进行异常仲裁。
    \item 整体上，I-Cache与D-Cache分别通过独立的AXI主接口访问指令/数据存储器，形成取指与访存的双通道结构。
\end{enumerate}

\newpage

\section{实验原理与设计}

\subsection{TLB模块}

\subsubsection{TLB参数设计}
设计采用全相联TLB，表项数为4。页大小固定为4KB（\textbf{VPN=addr[31:12]，offset=addr[11:0]}），每条表项包含VPN、PPN、valid、dirty位。采用固定映射（PPN=VPN）并在复位/首次时钟初始化valid/dirty为1，保证基本访问稳定可用。异常编码支持TLBL/TLBS/Modify，优先级为miss/invalid优先于modify。下图\ref{fig:TLB地址转换}主要是展示了一个地址转换的过程，左侧的TLB比较简单，就没有单独再绘制一个TLB的结构图了。（但是下面画了一个Cache的结构图）。


\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/TLB地址转换.png}
    \caption{TLB地址转换(设计图)}
    \label{fig:TLB地址转换}
\end{figure}

TLB（Translation Lookaside Buffer）用于加速虚拟地址到物理地址的转换。流水线访存时先用虚拟页号（VPN）在TLB中查找，如果命中则得到物理页号（PPN）并拼接页内偏移形成物理地址；若未命中或表项无效则触发TLB相关异常。

\subsubsection{代码部分：TLB接口与关键信号}
TLB作为MEM阶段前置地址转换单元，接口只保留最小必要信号，输入为访存请求与虚拟地址，输出为物理地址与异常信息：
\begin{lstlisting}[language=Verilog]
module tlb_simple(
    input             clk, input             resetn,
    input             req_valid,
    input      [31:0] vaddr,
    input             is_store,
    output reg        hit,
    output reg [31:0] paddr,
    output reg        exc_valid,
    output reg [ 4:0] exc_code,
    output reg        badvaddr_valid,
    output reg [31:0] badvaddr
);
\end{lstlisting}
其中，\textbf{req\_valid}在MEM阶段且为load/store时拉高，\textbf{vaddr}为EXE计算出的虚拟地址，\textbf{is\_store}用于区分TLBL/TLBS与Modify异常。TLB命中输出\textbf{paddr}，异常时输出\textbf{exc\_code}并带上\textbf{badvaddr}。

\subsubsection{代码部分：TLB查找输出}
TLB逻辑核心是“按VPN匹配并给出paddr/异常码”，代码如下（精简版）：
\begin{lstlisting}[language=Verilog]
// tlb_simple.v (simplified)
always @(*) begin
    hit = 1'b0; exc_valid = 1'b0; exc_code = 5'd0; paddr = vaddr;
    for (i = 0; i < TLB_ENTRIES; i = i + 1) begin
        if (tlb_valid[i] && tlb_vpn[i] == vaddr[31:12]) begin
            hit   = 1'b1;
            paddr = {tlb_ppn[i], vaddr[11:0]};
            if (!tlb_dirty[i] && is_store) begin
                exc_valid = 1'b1; exc_code = 5'd1; // Modify
            end
        end
    end
    if (!hit) begin
        exc_valid = 1'b1; exc_code = is_store ? 5'd3 : 5'd2; // TLBS/TLBL
    end
end
\end{lstlisting}


\paragraph{加了TLB后的一大改变}
之前的AXI接到的mem我只写了为256个word。实际访问时仅使用地址低位作为索引，高位地址会发生回绕（alias），因此逻辑地址范围大于物理存储容量时会映射到同一片存储区域。（简单来说就是直接把高位扔了，现在TLB可以在某种意义上实现一个简单的地址转换）。

\newpage


\subsection{Cache模块}


\subsection{I/D-Cache 参数设计}

两个cache虽然公能有区别，但是结构类似（设计的参数）：

共同点是直映结构、4 行、16B 行大小（byte offset = addr[1:0]， word offset = addr[3:2]，index = addr[5:4]，tag = addr[31:6]）



\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/一路.png}
    \caption{直接映射Cache结构设计图}
\end{figure}


具体到每个Cache的具体实现区别：

\begin{enumerate}
    \item I-Cache采用直映结构，4行，行大小16B（4个word）。索引为addr[5:4]，标记为addr[31:6]，字偏移为addr[3:2]。miss时发起burst长度4的AXI读事务，填充后更新tag与valid。接口采用req/resp握手，支持流水暂停等待。
    \item D-Cache采用直映结构，4行，行大小16B（4个word），索引与标记划分同I-Cache。写策略为写直达+写分配：store未命中先refill，再更新cache行并发起单次AXI写；load未命中则refill后返回数据。支持字/字节访问，字节写通过读-改-写合并实现，LB/LBU按符号/无符号扩展返回。
\end{enumerate}



\subsubsection{I/D-Cache区别}

I-Cache仅服务取指路径，属于只读缓存。取指地址先在I-Cache中查找，命中则直接返回指令；未命中则触发一次行填充（refill），从指令存储器按cache行大小进行burst读入，再返回所需指令。由于取指不涉及写操作，I-Cache不需要脏位与写回策略，实现更简单、时序更稳定。


D-Cache用于数据访存，支持读写操作。对load命中直接返回数据；对store命中先更新cache行，再根据写策略写到主存。未命中时需要行填充，之后再完成当前读/写。为了简化教学实现，本设计采用直映结构与写直达策略，避免复杂的替换与写回。总结可以为：

\begin{enumerate}
    \item I‑Cache 只读，只做取指；不需要写策略、字节合并、写直达
    \item D‑Cache 读写都要处理，包含写直达、写分配、LB/LBU/SB 的字节处理
\end{enumerate}

\subsubsection{代码部分：Cache接口与关键信号}
I-Cache为只读接口，采用req/resp握手，并通过AXI读通道完成refill：
\begin{lstlisting}[language=Verilog]
module icache_simple(
    input             clk, resetn,
    input             req_valid,
    input      [31:0] req_addr,
    output            req_ready,
    output reg        resp_valid,
    output reg [31:0] resp_inst,
    output reg        axi_start,
    output reg [31:0] axi_addr,
    output reg [7:0]  axi_len,
    input      [31:0] axi_rdata,
    input             axi_rvalid,
    input             axi_done,
    input             axi_busy
);
\end{lstlisting}
D-Cache在此基础上增加写通道与访问类型控制（字/字节），并向MEM返回读结果：
\begin{lstlisting}[language=Verilog]
module dcache_simple(
    input             clk, resetn,
    input             req_valid,
    input             req_is_store,
    input      [1:0]  req_size,      // 2'b10=word, 2'b00=byte
    input      [31:0] req_paddr,
    input      [31:0] req_wdata,
    output            req_ready,
    output reg        resp_valid,
    output reg [31:0] resp_rdata,
    output reg        axi_start,
    output reg        axi_rw,         // 1=read, 0=write
    output reg [31:0] axi_addr,
    output reg [7:0]  axi_len,
    output reg [31:0] axi_wdata,
    output reg        axi_wvalid,
    input             axi_wready,
    input      [31:0] axi_rdata,
    input             axi_rvalid,
    input             axi_done,
    input             axi_busy
);
\end{lstlisting}
I/D-Cache均采用直映结构：\textbf{index=addr[5:4]}、\textbf{tag=addr[31:6]}、\textbf{offset=addr[3:0]}。I-Cache只读、无写策略；D-Cache则包含写直达与写分配逻辑，并在store时触发AXI写事务。

\subsection{AXI与Cache连接代码说明}
本设计将I-Cache与D-Cache分别连接到两路AXI主接口：I-Cache只使用读通道，D-Cache使用读+写通道。核心连接在\texttt{pipeline\_cpu.v}中完成（精简版）：
\begin{lstlisting}[language=Verilog]
// I-Cache -> AXI (instruction)
assign instr_user_start = icache_axi_start;
assign instr_user_addr  = icache_axi_addr;
assign instr_user_len   = icache_axi_len;
assign icache_axi_done  = instr_user_done;

// D-Cache/MEM -> AXI (data)
assign data_user_start  = mem_axi_start;
assign data_user_addr   = mem_axi_addr;
assign data_user_len    = mem_axi_len;
assign mem_axi_done     = data_user_done;
\end{lstlisting}
含义是：取指与访存形成双通道，互不干扰；I-Cache只在miss时发起burst读，D-Cache则在miss或写直达时发起相应的读/写事务。


\subsection{TLB与Cache例外支持}

\subsubsection{设计思路}
为了让TLB与Cache接入后仍能产生正确的异常与中断处理，本设计在MEM阶段统一产生访存相关异常，并在WB阶段进行最终仲裁与送入CP0。整体流程如下：
\begin{enumerate}
    \item 地址对齐检查：LW/SW需要4字节对齐，未对齐则产生AdEL/AdES异常；
    \item TLB查找：对load/store虚拟地址执行TLB查找，若miss/invalid/modify则产生TLBL/TLBS/Modify异常；
    \item 异常优先级：TLB异常优先于地址错异常（先保证地址转换合法性）；
    \item Cache访问：只有在“无异常”情况下才进入D-Cache或AXI访问；
    \item 异常传递：MEM将异常标志与badvaddr打包进MEM\_WB\_bus，WB阶段统一仲裁并写入CP0。
\end{enumerate}

\subsubsection{代码实现}
\paragraph{TLB异常判定（tlb\_simple.v）}
TLB仅做最简命中判断与异常编码，支持TLBL/TLBS/Modify：
\begin{lstlisting}[language=Verilog]
if (req_valid) begin
    if (!match_found) begin
        exc_valid = 1'b1;
        exc_code  = is_store ? 5'd3 : 5'd2; // TLBS/TLBL
    end else if (!match_valid) begin
        exc_valid = 1'b1;
        exc_code  = is_store ? 5'd3 : 5'd2; // invalid -> TLBL/TLBS
    end else if (is_store && !match_dirty) begin
        exc_valid = 1'b1;
        exc_code  = 5'd1; // Modify
    end
end
\end{lstlisting}

\paragraph{MEM阶段异常生成与打包（mem.v）}
MEM先做对齐检查，再检查TLB异常；若有异常则不再访问D-Cache/AXI，并将异常打包到MEM\_WB\_bus：
\begin{lstlisting}[language=Verilog]
wire addr_unaligned = ls_word && (vaddr[1:0] != 2'b00);
wire mem_ex_adel = inst_load  && addr_unaligned;
wire mem_ex_ades = inst_store && addr_unaligned;

wire mem_ex_tlbl = tlb_exc_valid && (tlb_exc_code == 5'd2);
wire mem_ex_tlbs = tlb_exc_valid && (tlb_exc_code == 5'd3);
wire mem_ex_mod  = tlb_exc_valid && (tlb_exc_code == 5'd1);
wire mem_ex_any  = mem_ex_adel | mem_ex_ades | mem_ex_tlbl | mem_ex_tlbs | mem_ex_mod;

assign MEM_over = (inst_load | inst_store) ?
                  (mem_ex_any ? MEM_valid : cache_resp_valid) :
                  MEM_valid;

assign MEM_WB_bus = {
    rf_wen, rf_wdest, MEM_result, lo_result, hi_write, lo_write,
    mfhi, mflo, mtc0, mfc0, cp0r_addr, syscall, brk, eret,
    mem_ex_adel, mem_ex_ades, mem_ex_tlbl, mem_ex_tlbs, mem_ex_mod,
    vaddr, pc
};
\end{lstlisting}

\paragraph{WB阶段异常仲裁与CP0写入（wb.v）}
WB阶段将TLB异常与地址错等异常进行优先级仲裁，再送入CP0：
\begin{lstlisting}[language=Verilog]
assign wb_ex_valid_no_int = (mem_ex_tlbl_wb | mem_ex_tlbs_wb | mem_ex_mod_wb |
                             mem_ex_adel_wb | mem_ex_ades_wb | brk_wb | syscall) ? WB_valid : 1'b0;
assign wb_ex_code_no_int  = mem_ex_tlbl_wb ? 5'd2 :
                            mem_ex_tlbs_wb ? 5'd3 :
                            mem_ex_mod_wb  ? 5'd1 :
                            mem_ex_adel_wb ? 5'd4 :
                            mem_ex_ades_wb ? 5'd5 :
                            brk_wb ? 5'd9 : 5'd8;
\end{lstlisting}

上述实现保证了TLB异常与Cache访问解耦：只要出现地址转换异常，D-Cache与AXI访问就被抑制，并在WB阶段统一上报CP0处理。


\newpage

\section{实验结果}
本实验主要通过仿真日志验证TLB与Cache功能，覆盖如下测试场景：
\subsection{I-Cache命中与未命中示例}


\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/ICache.png}
\end{figure}

这里主要分析I-Cache中的这几个信号\texttt{data}、\texttt{hit}、\texttt{hit\_word}：以图中波形为例：在PC从\texttt{0x00000820}递增到\texttt{0x0000082C}的窗口内，\texttt{hit}保持为0，说明这些取指均处于\textbf{miss}状态；此时\texttt{hit\_word}仍会随offset变化给出候选字（如\texttt{00a23027}、\texttt{00c33825}、\texttt{00e64026}、\texttt{11030002}），但它只是data阵列的直读结果，并不代表最终命中输出。待refill完成后，\texttt{hit}拉高，I-Cache才会真正命中并输出稳定指令。该现象与I-Cache的命中/回填逻辑一致。




\subsection{D-Cache写直达示例（store）}


\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/Dc.png}

\end{figure}

另一个角度可以看display出来的详细信息，我在写代码的时候增加了display的调错信息，例如以对地址\texttt{0x00000014}的store为例，D-Cache命中后先更新cache行，再通过AXI写直达主存：
\begin{lstlisting}[language=Verilog]
TLB_LOOKUP: vaddr=00000014 ... hit=1 ... exc=0
D$ REQ: addr=00000014 ... hit=1 is_store=1 size=10
D$ HIT-STORE-W: new=0000000d
D$ WRITE-START: addr=00000014 wdata=0000000d
PIPE_AXI_DATA: start rw=0 addr=00000014 len=1
\end{lstlisting}
该过程说明store命中时不会等待refill，直接进入写直达阶段；AXI写完成后出现\texttt{WRITE-DONE}。




\subsection{TLB命中与异常示例}

大致流程是TLB命中时\texttt{TLB\_LOOKUP}显示hit=1且exc=0；若映射无效或越界，则出现TLBL/TLBS/Modify异常并在WB仲裁后写入CP0（日志含异常码与badvaddr）。

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/TLB_match_miss.png}
    \caption{TLB命中和非命中}
\end{figure}




\subsection{流水暂停示例}
Cache miss或AXI busy时，MEM\_allow\_in拉低导致流水暂停；回填或写回完成后恢复。以下以一次store写直达为例：
\begin{lstlisting}[language=Verilog]
D$ HIT-STORE-W: new=00000011
D$ WRITE-START: addr=0000001c wdata=00000011
PIPE_AXI_DATA: start rw=0 addr=0000001c len=1
... (MEM_allow_in=0 持续，流水暂停)
D$ WRITE-DONE
\end{lstlisting}
该过程中MEM阶段等待AXI写完成，EXE/ID级无法继续前推，直到出现\texttt{WRITE-DONE}后流水恢复。

综合以上场景，仿真输出与预期一致，说明TLB、I/D-Cache与AXI接口集成正确。






\section{实验总结}
本次实验在原有五级流水CPU上完成了TLB与I/D Cache的最简集成，并通过AXI双通道实现指令与数据的并行访问。通过在MEM阶段统一产生访存异常、在WB阶段统一仲裁上报CP0，保证了TLB异常与对齐异常的正确优先级与处理路径。I-Cache采用只读直映结构，D-Cache采用写直达+写分配，既简化了控制，又能覆盖典型访存场景。仿真日志显示：取指/访存命中路径、miss回填路径、写直达时的流水暂停以及TLB异常上报均按设计运行。整体设计满足教学级“简单、稳定、可解释”的目标，也为后续扩展更复杂的替换策略、写回策略与TLB管理机制打下基础。
\label{LastPage}

\end{document}
